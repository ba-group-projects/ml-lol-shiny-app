_HiStOrY_V2_
q
q()
library(shiny); runApp('OneDrive/Documents/MyOversea/Cass Study/revenue management and pricing/problem set1/problem_set.R')
runApp('OneDrive/Documents/MyOversea/Cass Study/revenue management and pricing/problem set1/problem_set.R')
library(shiny); runApp('OneDrive/Documents/MyOversea/Cass Study/revenue management and pricing/problem set1/problem_set.R')
ExpRevenue = bestAllocation$"ExpRevenue"
RevenueFCFS <- ExpRevenue[1]
print(paste("Lower Bound for Expected Revenue (FCFS):", round(RevenueFCFS, 1)))
ProtectBest = ExpRevenue$ProtectBest
print(paste("The Optimal Protection Level for High-Fare Demand:", ProtectBest))
## function ----
### define a function to calculate the ExpRevenue, ProtectBest and OptimalExpRevenue according to
### the meanDemandForCroissant, meanDemandForSandwich and capacity input
findBestAllocation <- function (meanDemandForCroissant=50,meanDemandForSandwich=20,capacity=50,priceForCroissant=1, priceForSandwich=1.5){
mL <- meanDemandForCroissant
mH <- meanDemandForSandwich
pL <- priceForCroissant
pH <- priceForSandwich
capacity <- capacity
ExpRevenue=rep(0,capacity+1)
for (i in 1:(capacity+1)){
protect=i-1
availforLowFare=capacity-protect;
ExpRevenue[i]=0;
for(dL in 0:100){
soldLowFare=min(availforLowFare,dL)
remainforHighFare=capacity-soldLowFare
for(dH in 0:100){
soldHighFare=min(remainforHighFare,dH)
RevenueThisIter=pL*soldLowFare+pH*soldHighFare
ExpRevenue[i]=ExpRevenue[i]+ RevenueThisIter*dpois(dL,mL)*dpois(dH,mH)
}
}
}
Protectindexbest = which(ExpRevenue == max(ExpRevenue))
ProtectBest=Protectindexbest-1
OptimalExpRevenue=max(ExpRevenue)
res =   list(
meanDemandForCroissant= meanDemandForCroissant,
meanDemandForSandwich = meanDemandForSandwich,
pL = priceForCroissant,
pH = priceForSandwich,
capacity = capacity,
ExpRevenue=ExpRevenue,
ProtectBest=ProtectBest,
OptimalExpRevenue=OptimalExpRevenue
)
return(res)
}
bestAllocation = findBestAllocation()
#
# # 1.1 ----
ExpRevenue = bestAllocation$"ExpRevenue"
RevenueFCFS <- ExpRevenue[1]
print(paste("Lower Bound for Expected Revenue (FCFS):", round(RevenueFCFS, 1)))
# 1.2 ---------
# Mean Demand for Low-Fare, Poisson # Mean Demand for High-Fare, Poisson # Price for Low-Fare # Price for Low-Fare # Capacity
ProtectBest = ExpRevenue$ProtectBest
print(paste("The Optimal Protection Level for High-Fare Demand:", ProtectBest))
# # 1.1 ----
ExpRevenue = bestAllocation$"ExpRevenue"
RevenueFCFS <- ExpRevenue[1]
print(paste("Lower Bound for Expected Revenue (FCFS):", round(RevenueFCFS, 1)))
# 1.2 ---------
# Mean Demand for Low-Fare, Poisson # Mean Demand for High-Fare, Poisson # Price for Low-Fare # Price for Low-Fare # Capacity
ProtectBest = bestAllocation$ProtectBest
print(paste("The Optimal Protection Level for High-Fare Demand:", ProtectBest))
capacity <- bestAllocation$capacity
xaxis=0:capacity
plot(xaxis,ExpRevenue,pch = 16, cex = 0.5,las=1, xaxt="n",
xlab="Croissants Protected",ylab="Expected Revenue",cex.lab=1.5, cex.axis=1.5, cex.main=1.5)
xticks <- seq(0, capacity, by=50)
axis(side = 1, at = xticks)
axis(side = 1, at = ProtectBest)
lines(c(ProtectBest,ProtectBest),c(0, max(ExpRevenue)),lty=2)
axis(side = 2, at = round(max(ExpRevenue),2),las=1)
lines(c(0,ProtectBest),c(max(ExpRevenue), max(ExpRevenue)),lty=2)
print(paste("The expected daily revenue from this protection (reserve) policy:", ExpRevenue[Protectindexbest]))
print(paste("The percentage improvement compared to the expected daily revenue from the FCFS allocation :", round(ExpRevenue[Protectindexbest]/round(RevenueFCFS, 1)-1,4)*100,'%'))
print(paste("The expected daily revenue from this protection (reserve) policy:", ExpRevenue$ProtectBest))
print(paste("The expected daily revenue from this protection (reserve) policy:", ExpRevenue$OptimalExpRevenue))
print(paste("The expected daily revenue from this protection (reserve) policy:", bestAllocation$OptimalExpRevenue))
print(paste("The percentage improvement compared to the expected daily revenue from the FCFS allocation :", round(ExpRevenue[Protectindexbest]/round(RevenueFCFS, 1)-1,4)*100,'%'))
print(paste("The percentage improvement compared to the expected daily revenue from the FCFS allocation :", round(bestAllocation$OptimalExpRevenue/round(RevenueFCFS, 1)-1,4)*100,'%'))
# Network Revenue Management with Dynamic Porgramming
N1=100; # Leg 1 seat availability
N2=120; # Leg 2 seat availability
TT=300; # Length of time horizon
arrivalprob=c(1/5, 4/15, 1/6, 4/15, 1/20);
price=c(150,120,250,180,200);
# R requires arrays be created at the beginning.
# Creating empty arrays of correct dimensions.
# For the value function v(x1,x2,t):
v=array(rep( 0, len=(N1+1)*(N2+1)*(TT+1)), dim=c(N1+1,N2+1,TT+1));
# To keep track of optimal decisions,
# e.g. acceptance decision for a product 1 arrival: accept1(x1,x2,t):
accept1=array(rep( 0, len=(N1+1)*(N2+1)*(TT+1)), dim=c(N1+1,N2+1,TT+1));
# remaining are similarly defined and created.
accept2=array(rep( 0, len=(N1+1)*(N2+1)*(TT+1)), dim=c(N1+1,N2+1,TT+1));
accept3=array(rep( 0, len=(N1+1)*(N2+1)*(TT+1)), dim=c(N1+1,N2+1,TT+1));
accept4=array(rep( 0, len=(N1+1)*(N2+1)*(TT+1)), dim=c(N1+1,N2+1,TT+1));
accept5=array(rep( 0, len=(N1+1)*(N2+1)*(TT+1)), dim=c(N1+1,N2+1,TT+1));
totalarrivalprob=sum(arrivalprob);
noarrivalprob=1-totalarrivalprob;
# Terminal Values
for(i in 1:(N1+1)){
for(j in 1:(N2+1)){
v[i,j,1]=0; # All seats worthless at the end of horizon, i.e., t=1.
}
}
# Dynamic Programming Algorithm
for(t in 2:(TT+1)){ #2:TT+1
for(i in 1:(N1+1)){ #1:N1+1
for(j in 1:(N2+1)){ #1:N2+1
# For no arrivals:
vforarrival0=v[i,j,t-1];
# For Product 1 arrival:
# default not accept unless able/profitable to accept
vforarrival1=v[i,j,t-1];
accept1[i,j,t]=0;
# If resource available:
if(i>1){
vforarrival1=max(price[1]+v[i-1,j,t-1],v[i,j,t-1]);
# Recording the decision in the accept1 variable:
if(price[1]+v[i-1,j,t-1]>v[i,j,t-1]){
accept1[i,j,t]=1;
}
}
# For Product 2 arrival:
# default not accept unless able/profitable to accept
vforarrival2=v[i,j,t-1];
accept2[i,j,t]=0;
# If resource available:
if(j>1){
vforarrival2=max(price[2]+v[i,j-1,t-1],v[i,j,t-1]);
# Recording the decision in the accept2 variable:
if(price[2]+v[i,j-1,t-1]>v[i,j,t-1]){
accept2[i,j,t]=1;
}
}
# For Product 3 arrival:
# default not accept unless able/profitable to accept
vforarrival3=v[i,j,t-1];
accept3[i,j,t]=0;
# If resources available:
if(i>1){
if(j>1){
vforarrival3=max(price[3]+v[i-1,j-1,t-1],v[i,j,t-1]);
# Recording the decision in the accept3 variable:
if(price[3]+v[i-1,j-1,t-1]>v[i,j,t-1]){
accept3[i,j,t]=1;
}
}
}
# For Product 4 arrival:
# default not accept unless able/profitable to accept
vforarrival4=v[i,j,t-1];
accept4[i,j,t]=0;
# If resources available:
if(i>1){
if(j>1){
vforarrival4=max(price[4]+v[i-1,j-1,t-1],v[i,j,t-1]);
# Recording the decision in the accept4 variable:
if(price[4]+v[i-1,j-1,t-1]>v[i,j,t-1]){
accept4[i,j,t]=1;
}
}
}
# For Product 5 arrival:
# default not accept unless able/profitable to accept
vforarrival5=v[i,j,t-1];
accept1[i,j,t]=0;
# If resource available:
if(i>1){
vforarrival5=max(price[5]+v[i-1,j,t-1],v[i,j,t-1]);
# Recording the decision in the accept1 variable:
if(price[5]+v[i-1,j,t-1]>v[i,j,t-1]){
accept1[i,j,t]=1;
}
}
# Obtaining the overall value function from its parts:
v[i,j,t]=noarrivalprob*vforarrival0+
arrivalprob[1]*vforarrival1+
arrivalprob[2]*vforarrival2+
arrivalprob[3]*vforarrival3+
arrivalprob[4]*vforarrival4+
arrivalprob[5]*vforarrival5;
}
}
}
1- sum(1/5, 4/15, 1/6, 4/15, 1/20)
knitr::opts_chunk$set(echo = TRUE)
findBestAllocation <- function (meanDemandForCroissant=50,meanDemandForSandwich=20,capacity=50,priceForCroissant=1, priceForSandwich=1.5){
mL <- meanDemandForCroissant
mH <- meanDemandForSandwich
pL <- priceForCroissant
pH <- priceForSandwich
capacity <- capacity
ExpRevenue=rep(0,capacity+1)
for (i in 1:(capacity+1)){
protect=i-1
availforLowFare=capacity-protect;
ExpRevenue[i]=0;
for(dL in 0:100){
soldLowFare=min(availforLowFare,dL)
remainforHighFare=capacity-soldLowFare
for(dH in 0:100){
soldHighFare=min(remainforHighFare,dH)
RevenueThisIter=pL*soldLowFare+pH*soldHighFare
ExpRevenue[i]=ExpRevenue[i]+ RevenueThisIter*dpois(dL,mL)*dpois(dH,mH)
}
}
}
Protectindexbest = which(ExpRevenue == max(ExpRevenue))
ProtectBest=Protectindexbest-1
OptimalExpRevenue=max(ExpRevenue)
res =   list(
meanDemandForCroissant= meanDemandForCroissant,
meanDemandForSandwich = meanDemandForSandwich,
pL = priceForCroissant,
pH = priceForSandwich,
capacity = capacity,
ExpRevenue=ExpRevenue,
ProtectBest=ProtectBest,
OptimalExpRevenue=OptimalExpRevenue
)
return(res)
}
bestAllocation = findBestAllocation() # Call the function and get results
ExpRevenue = bestAllocation$"ExpRevenue" # Get the ExpRevenue under different numbers of protected croissants
RevenueFCFS <- ExpRevenue[1] # Because FCFS means no protected croissants, thus we choose the first number in the ExpRevenue, which means protection level is 0
print(paste("Lower Bound for Expected Revenue (FCFS):", round(RevenueFCFS, 1)))
ProtectBest = bestAllocation$ProtectBest # In the definition of the function, we can find the max revenue and then find the corresponding Protection Level.
print(paste("The Optimal Protection Level for Sandwiches:", ProtectBest))
# Plotting Expected Revenue vs Protection Level
capacity <- bestAllocation$capacity
xaxis=0:capacity
plot(xaxis,ExpRevenue,pch = 16, cex = 0.5,las=1, xaxt="n",
xlab="Croissants Protected",ylab="Expected Revenue",cex.lab=1.5, cex.axis=1.5, cex.main=1.5)
xticks <- seq(0, capacity, by=50)
axis(side = 1, at = xticks)
axis(side = 1, at = ProtectBest)
lines(c(ProtectBest,ProtectBest),c(0, max(ExpRevenue)),lty=2)
axis(side = 2, at = round(max(ExpRevenue),2),las=1)
lines(c(0,ProtectBest),c(max(ExpRevenue), max(ExpRevenue)),lty=2)
print(paste("The expected daily revenue from this protection (reserve) policy:", round(ExpRevenue[Protectindexbest],2)))
print(paste("The expected daily revenue from this protection (reserve) policy:", round(ExpRevenue[ProtectBest$Protectindexbest],2)))
print(paste("The expected daily revenue from this protection (reserve) policy:", round(ExpRevenue[bestAllocation$Protectindexbest],2)))
print(paste("The percentage improvement compared to the expected daily revenue from the FCFS allocation :", round(ExpRevenue[bestAllocation$Protectindexbest]/round(RevenueFCFS, 1)-1,4)*100,'%'))
RevenueFCFS
round(ExpRevenue[bestAllocation$Protectindexbest],2)
bestAllocation$Protectindexbest]
bestAllocation$Protectindexbest
bestAllocation = findBestAllocation() # Call the function and get results
ExpRevenue = bestAllocation$"ExpRevenue" # Get the ExpRevenue under different numbers of protected croissants
RevenueFCFS <- ExpRevenue[1] # Because FCFS means no protected croissants, thus we choose the first number in the ExpRevenue, which means protection level is 0
print(paste("Lower Bound for Expected Revenue (FCFS):", round(RevenueFCFS, 1)))
bestAllocation
bestAllocation$Protectindexbest
ProtectBest
print(paste("The expected daily revenue from this protection (reserve) policy:",round(ExpRevenue[bestAllocation$ProtectBest],2)))
print(paste("The expected daily revenue from this protection (reserve) policy:",round(ExpRevenue[bestAllocation$ProtectBest+1],2)))
print(paste("The percentage improvement compared to the expected daily revenue from the FCFS allocation :", round(ExpRevenue[bestAllocation$ProtectBest]/round(RevenueFCFS, 1)-1,4)*100,'%'))
knitr::opts_chunk$set(echo = TRUE)
expectedRevenue = round(max(ExpRevenueProtectindexbest),2)
expectedRevenue = round(max(ExpRevenueProtect),2)
expectedRevenue = round(max(bestAllocation$ExpRevenueProtect),2)
ProtectBest = bestAllocation$ProtectBest # In the definition of the function, we can find the max revenue and then find the corresponding Protection Level.
findBestAllocation <- function (meanDemandForCroissant=50,meanDemandForSandwich=20,capacity=50,priceForCroissant=1, priceForSandwich=1.5){
mL <- meanDemandForCroissant
mH <- meanDemandForSandwich
pL <- priceForCroissant
pH <- priceForSandwich
capacity <- capacity
ExpRevenue=rep(0,capacity+1)
for (i in 1:(capacity+1)){
protect=i-1
availforLowFare=capacity-protect;
ExpRevenue[i]=0;
for(dL in 0:100){
soldLowFare=min(availforLowFare,dL)
remainforHighFare=capacity-soldLowFare
for(dH in 0:100){
soldHighFare=min(remainforHighFare,dH)
RevenueThisIter=pL*soldLowFare+pH*soldHighFare
ExpRevenue[i]=ExpRevenue[i]+ RevenueThisIter*dpois(dL,mL)*dpois(dH,mH)
}
}
}
Protectindexbest = which(ExpRevenue == max(ExpRevenue))
ProtectBest=Protectindexbest-1
OptimalExpRevenue=max(ExpRevenue)
res =   list(
meanDemandForCroissant= meanDemandForCroissant,
meanDemandForSandwich = meanDemandForSandwich,
pL = priceForCroissant,
pH = priceForSandwich,
capacity = capacity,
ExpRevenue=ExpRevenue,
ProtectBest=ProtectBest,
OptimalExpRevenue=OptimalExpRevenue
)
return(res)
}
bestAllocation = findBestAllocation() # Call the function and get results
ExpRevenue = bestAllocation$"ExpRevenue" # Get the ExpRevenue under different numbers of protected croissants
RevenueFCFS <- ExpRevenue[1] # Because FCFS means no protected croissants, thus we choose the first number in the ExpRevenue, which means protection level is 0
print(paste("Lower Bound for Expected Revenue (FCFS):", round(RevenueFCFS, 1)))
expectedRevenue = round(max(bestAllocation$ExpRevenueProtect),2)
percentage = round(ExpRevenue[Protectindexbest]/round(RevenueFCFS, 1)-1,4)*100
expectedRevenue = round(max(bestAllocation$ExpRevenueProtect),2)
percentage = round(expectedRevenue/round(RevenueFCFS, 1)-1,4)*100
print(paste("The expected daily revenue from this protection (reserve) policy:", expectedRevenue))
print(paste("The percentage improvement compared to the expected daily revenue from the FCFS allocation :",percentage,"%" ))
bestAllocation
max(bestAllocation$ExpRevenue)
expectedRevenue = round(max(bestAllocation$ExpRevenue),2)
percentage = round(expectedRevenue/round(RevenueFCFS, 1)-1,4)*100
print(paste("The expected daily revenue from this protection (reserve) policy:", expectedRevenue))
print(paste("The percentage improvement compared to the expected daily revenue from the FCFS allocation :",percentage,"%" ))
shiny::runApp('OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
setwd("~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App")
runApp('~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
runApp('~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
runApp('~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
runApp('~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
runApp('~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
runApp('~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
runApp('~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
runApp('~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
runApp('~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
runApp('~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
runApp('~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
runApp('~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
runApp('~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
runApp('~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
runApp('~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
runApp('~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
runApp('~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
runApp('~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
runApp('~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
runApp('~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
runApp('~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
runApp('~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
runApp('~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
runApp('~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
runApp('~/OneDrive/Documents/MyOversea/Cass Study/machine learning/MTP/MTP1/machine-learning-gp1/App')
